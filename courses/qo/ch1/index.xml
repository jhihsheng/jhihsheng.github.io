<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ðŸ“Š Field Quantization | Quantum Nano-Optics</title>
    <link>https://jhihsheng.github.io/courses/qo/ch1/</link>
      <atom:link href="https://jhihsheng.github.io/courses/qo/ch1/index.xml" rel="self" type="application/rss+xml" />
    <description>ðŸ“Š Field Quantization</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hant</language><copyright>Â© 2022 Jhih-Sheng Wu</copyright><lastBuildDate>Wed, 23 Feb 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://jhihsheng.github.io/media/icon_hu1386fbeed7d8c69c6cc5197e05785de8_303108_512x512_fill_lanczos_center_3.png</url>
      <title>ðŸ“Š Field Quantization</title>
      <link>https://jhihsheng.github.io/courses/qo/ch1/</link>
    </image>
    
    <item>
      <title>Harmonic Ocsillator</title>
      <link>https://jhihsheng.github.io/courses/qo/ch1/harmonic_oscillator/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://jhihsheng.github.io/courses/qo/ch1/harmonic_oscillator/</guid>
      <description>&lt;p&gt;We show how to compute the harmonic oscillator in the number basis. We use the quantum toolbox in Python,
qutip.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from qutip import *
from qutip.distributions import *
import numpy as np
import matplotlib.pyplot as plt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We begin with the number basis. &amp;lsquo;a = destroy()&amp;rsquo; genrerates the annillation operator in the numner basis.
$$ a = \begin{bmatrix} 0 &amp;amp; 0 &amp;amp; 0&amp;amp;\dots\\&lt;br&gt;
1 &amp;amp; 0 &amp;amp;  0&amp;amp;\dots\\&lt;br&gt;
0 &amp;amp;\sqrt{2}&amp;amp;0&amp;amp;\dots\\&lt;br&gt;
0 &amp;amp; 0 &amp;amp;\sqrt{3} &amp;amp;\ddots           &lt;br&gt;
\end{bmatrix}  $$
Then, we write $x$ and $p$ operators in the number basis,
$$ x = \frac{a+a^{\dagger}}{2}, \&lt;br&gt;
p  = \frac{a-a^{\dagger}}{2i},$$
and compute the eigenbasis of $x$ operator, that is, to express $|x_i\rangle$ in the number basis.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## create the operators in the number basis (Fock basis)
N = 501 # the maximum number of the photon number
a = destroy(N)
x = (a + a.dag())/2
p = (a - a.dag())/2j

# to find the basis vectors of x operator (but expressed in the number basis) 
x_vals, x_states = x.eigenstates()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;discussion-here-is-more-advanced-you-can-skip-this-part&#34;&gt;Discussion here is more advanced. You can skip this part.&lt;/h3&gt;
&lt;p&gt;The problem here is related to the gauge fixing of the phase. Since the phases of the eigenstates can be arbitrary, there exist  the degree of freedom to add the phase
$$ |x_\mathrm{new} \rangle = \exp{i\phi(x)}|x \rangle,$$
where $\phi(x)$ is an arbitrary funciton. When we obtain $|x\rangle $ numerically, it may occur that
$\phi(x)$ is not a continuous funciton of $x$. The discontinuity will cause problems, says when
computing the derivatives of wavefunctions with respect to $x$. Below, we remedy the issue.&lt;/p&gt;
&lt;p&gt;The basis vectors $|x_i\rangle$  by &amp;lsquo;x_states&amp;rsquo; are obtained by the exact diagonalization of the $x$ matrix.
A typical problem of numerically obtained $|x_i\rangle$ is that the phase of different $|x_i\rangle$ is not continuous in $x$. This leads to the problem of discontinuities  of $\psi(x)$. To fix this problem,
we require the following condition
$$\mathrm{Arg}[\langle x_{i+1}|p|x_i\rangle]= \frac{\pi}{2}. $$&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#  The x_states contains the eigenvectors. However, the phase of each eigenvector is not continuous 
#  as a function of xi.
#  This casuses a problem that the wavefunciton psi(x) is not continuous.
# # The way to remedy the issue is to make &amp;lt;xi+1|p|xi&amp;gt; have the same phase   
x_states[0] = - x_states[0] # to fix the phase such that psi_0(x) &amp;gt;0
for i in range(N-1):
    tmp1 = x_states[i+1].dag()*p*x_states[i]
    ph = np.angle(tmp1)
    ph_c = np.pi/2 - ph[0,0]
    x_states[i+1] = np.exp(1j* ph_c)* x_states[i+1]
    
    
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## plot the harmonic potential V = 1/2 x^2

plt.figure(dpi=150,figsize=(12,5))
# subplot 1
plt.subplot(1,2,1)
plt.plot(x_vals, x_vals**2/2)
plt.fill_between(x_vals, 0., x_vals**2/2, alpha=0.2)
## plot the probabilities of the eigenstates
for i in range(5):
    psi = fock(N,i) ## fock states are the eigenstates of a harmonic oscillator
    Ei = 1/2 + i 
    psi_x = psi.transform(x_states)
    y1 = np.abs(psi_x.full())**2 * 15 + Ei
    y1 = np.real(psi_x.full()) * 2 + Ei
    y1 = np.reshape(y1,(N,))
    plt.plot(x_vals, y1)
    plt.fill_between(x_vals, Ei, y1 , alpha=0.2)       
plt.ylabel(r&amp;quot;$\frac{E_n}{\hbar\omega}$&amp;quot;)
plt.xlabel(r&amp;quot;$x$&amp;quot;)
plt.xlim([-3,3])
plt.ylim([0,5.5])
plt.text(0.7,1, &#39;$\psi_0(x)$&#39;)
plt.text(1.2,2, &#39;$\psi_1(x)$&#39;)
plt.text(1.6,3, &#39;$\psi_2(x)$&#39;)
plt.text(2,4, &#39;$\psi_3(x)$&#39;)
plt.text(2.2,5, &#39;$\psi_4(x)$&#39;);

# subplot 2
plt.subplot(1,2,2)
plt.plot(x_vals, x_vals**2/2)
plt.fill_between(x_vals, 0., x_vals**2/2, alpha=0.2)
## plot the probabilities of the eigenstates
for i in range(5):
    psi = fock(N,i) ## fock states are the eigenstates of a harmonic oscillator
    Ei = 1/2 + i 
    psi_x = psi.transform(x_states)
    y1 = np.abs(psi_x.full())**2 * 15 + Ei
    y1 = np.reshape(y1,(N,))
    plt.plot(x_vals, y1)
    plt.fill_between(x_vals, Ei, y1 , alpha=0.2)       
plt.ylabel(r&amp;quot;$\frac{E_n}{\hbar\omega}$&amp;quot;)
plt.xlabel(r&amp;quot;$x$&amp;quot;)
plt.xlim([-3,3])
plt.ylim([0,5.5])
plt.text(0.7,1, &#39;$|\psi_0(x)|^2$&#39;)
plt.text(1.2,2, &#39;$|\psi_1(x)|^2$&#39;)
plt.text(1.6,3, &#39;$|\psi_2(x)|^2$&#39;)
plt.text(2,4, &#39;$|\psi_3(x)|^2$&#39;)
plt.text(2.2,5, &#39;$|\psi_4(x)|^2$&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jhihsheng.github.io/QO_2022/ho_1.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from qutip.ipynbtools import version_table
version_table()
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;&lt;tr&gt;&lt;th&gt;Software&lt;/th&gt;&lt;th&gt;Version&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;QuTiP&lt;/td&gt;&lt;td&gt;4.6.3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Numpy&lt;/td&gt;&lt;td&gt;1.22.2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SciPy&lt;/td&gt;&lt;td&gt;1.8.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;matplotlib&lt;/td&gt;&lt;td&gt;3.4.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Cython&lt;/td&gt;&lt;td&gt;0.29.28&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Number of CPUs&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLAS Info&lt;/td&gt;&lt;td&gt;OPENBLAS&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IPython&lt;/td&gt;&lt;td&gt;8.1.1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Python&lt;/td&gt;&lt;td&gt;3.10.2 | packaged by conda-forge | (main, Feb  1 2022, 19:29:00) [GCC 9.4.0]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OS&lt;/td&gt;&lt;td&gt;posix [linux]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&#39;2&#39;&gt;Sun Mar 06 16:06:18 2022 CST&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Instead of using the Fock states (number states), we compute the eigenstates dierectly from the hamiltonians.
Of course, we will obtain the same results.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hamil =  x**2 + p**2
en_vals, h_states = hamil.eigenstates()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plt.figure(dpi=150)
plt.plot(x_vals, x_vals**2/2)
plt.fill_between(x_vals, 0., x_vals**2/2, alpha=0.2)

## plot the probabilities of the eigenstates

for i in range(5):
    Ei = 1/2 + i 
    psi_x = h_states[i].transform(x_states)
    y1 = np.abs(psi_x.full())**2 * 15 + Ei
    y1 = np.reshape(y1,(N,))
    plt.plot(x_vals, y1)
    plt.fill_between(x_vals, Ei, y1 , alpha=0.2)

plt.ylabel(r&amp;quot;$\frac{E_n}{\hbar\omega}$&amp;quot;)
plt.xlabel(r&amp;quot;$x$&amp;quot;)
plt.xlim([-3,3])
plt.ylim([0,6])
plt.text(0.7,1, &#39;$|\psi_0(x)|^2$&#39;)
plt.text(1.2,2, &#39;$|\psi_1(x)|^2$&#39;)
plt.text(1.6,3, &#39;$|\psi_2(x)|^2$&#39;)
plt.text(2,4, &#39;$|\psi_3(x)|^2$&#39;)
plt.text(2.2,5, &#39;$|\psi_4(x)|^2$&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://jhihsheng.github.io/QO_2022/ho_2.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Phase States</title>
      <link>https://jhihsheng.github.io/courses/qo/ch1/plot_phase_states/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://jhihsheng.github.io/courses/qo/ch1/plot_phase_states/</guid>
      <description>&lt;p&gt;The plot of the phase states.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib
import matplotlib.pyplot as plt
import numpy as np
# Data for plotting
phi1 = 0.5 * np.pi
phi2 = 0.7 * np.pi
Nmax = 30
phi = np.arange(0.0, 2.0 * np.pi, 0.01)
# define the phase distribution function 
def phase_dist_func(x,y):
    return np.sin(Nmax*(x-y)/2)**2./np.sin((x-y)/2)**2/Nmax/(2*np.pi)
phase_dist_1 = phase_dist_func(phi,phi1)
phase_dist_2 = phase_dist_func(phi,phi2)
## plot
fig, ax = plt.subplots()
ax.plot(phi, phase_dist_1,label=r&#39;$|\phi_1=0.5\pi\rangle$&#39;) 
## r: raw string
ax.plot(phi, phase_dist_2,label=r&#39;$|\phi_2=0.7\pi\rangle$&#39;) 
## r: raw string
ax.set(xlabel=&#39;$\phi$ &#39;, ylabel=&#39;$\mathcal{P}(\phi)$&#39;,
       title=&#39;Phase Distribution Function of a Phase State&#39;)
ax.grid()
plt.legend()
fig.savefig(&amp;quot;phase_dist.png&amp;quot;, dpi=300,facecolor=&#39;white&#39;, transparent=False)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;png&#34; srcset=&#34;
               /media/output_0_1_hufd834839036becc158b5d453c2e0787e_29444_e76650b6f6b34e512feaed2ff4c4dfd6.png 400w,
               /media/output_0_1_hufd834839036becc158b5d453c2e0787e_29444_ebfc2250bfb66d69e2b58a72b0d83c19.png 760w,
               /media/output_0_1_hufd834839036becc158b5d453c2e0787e_29444_1200x1200_fit_lanczos_3.png 1200w&#34;
               src=&#34;https://jhihsheng.github.io/media/output_0_1_hufd834839036becc158b5d453c2e0787e_29444_e76650b6f6b34e512feaed2ff4c4dfd6.png&#34;
               width=&#34;533&#34;
               height=&#34;395&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;h2 id=&#34;to-test-uploading-from-desktop&#34;&gt;To test uploading from desktop&lt;/h2&gt;</description>
    </item>
    
  </channel>
</rss>
